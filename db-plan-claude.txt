# INKRA DATABASE ARCHITECTURE PLAN
## Complete Migration from PostgreSQL to Serverless + On-Device Storage

## EXECUTIVE SUMMARY
Complete elimination of PostgreSQL database in favor of:
1. **AWS Cognito** for user management and basic attributes
2. **DynamoDB** for rate limiting and usage tracking (minimal, server-side only)
3. **CoreData** for all user content (interviews, audio, transcripts) stored locally on device
4. **Zero remote storage** of user-generated content for maximum privacy

## 1. CURRENT DATABASE ANALYSIS

### 1.1 Current PostgreSQL Schema (377 lines, 20+ tables)
**User & Auth Tables:**
- users (email, password, admin, interests)
- device_logs (logging)
- feedbacks (user feedback)
- user_data_exports (GDPR compliance)

**Content Tables:**
- projects (interviews)
- chapters, sections, questions (interview structure)
- audio_segments (audio files + S3 URLs)
- transcripts, transcript_content (transcriptions)
- polly_audio_clips (TTS audio)

**Feature Tables:**
- interview_presets (templates)
- generation_interviews/questions/responses (multi-speaker)
- trackers, log_entries (habit tracking)
- advisor_interactions (AI advisors)

### 1.2 Data Relationships
```
User → Projects → Chapters → Sections → Questions → AudioSegments
                          ↘ Transcripts → TranscriptContent
```

**Key Insights:**
- Heavy relational structure (20+ foreign keys)
- Significant remote storage (S3 for audio)
- Complex permission system
- Overkill for single-user mobile app

## 2. NEW DATABASE ARCHITECTURE

### 2.1 Architecture Overview
```
┌──────────────────────────────────────────────────────────┐
│                     iOS DEVICE                            │
│  ┌────────────────────────────────────────────────────┐  │
│  │         CoreData (Local SQLite)                    │  │
│  │  - All interviews, questions, audio metadata       │  │
│  │  - User preferences                                │  │
│  │  - Cached templates                                │  │
│  └────────────────────────────────────────────────────┘  │
│  ┌────────────────────────────────────────────────────┐  │
│  │         Documents Directory                        │  │
│  │  - Audio files (.m4a)                             │  │
│  │  - Exported podcasts                              │  │
│  └────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────┘
                            │
                            ↓
┌──────────────────────────────────────────────────────────┐
│                    AWS CLOUD                              │
│  ┌────────────────────────────────────────────────────┐  │
│  │         AWS Cognito User Pool                      │  │
│  │  - User authentication (email/password)            │  │
│  │  - User attributes:                                │  │
│  │    • subscription_tier (free/premium)              │  │
│  │    • monthly_quota (5/unlimited)                   │  │
│  │    • signup_date                                   │  │
│  └────────────────────────────────────────────────────┘  │
│  ┌────────────────────────────────────────────────────┐  │
│  │         DynamoDB (Single Table)                    │  │
│  │  Table: inkra-usage                                │  │
│  │  - User usage tracking                             │  │
│  │  - Rate limiting counters                          │  │
│  └────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────┘
```

## 3. RATE LIMITING ARCHITECTURE

### 3.1 The Security Challenge
**CANNOT trust client-side enforcement because:**
- iOS apps can be jailbroken
- Network traffic can be intercepted (man-in-the-middle)
- Local databases can be modified
- Binary can be reverse-engineered
- API calls can be replayed

**MUST enforce server-side because:**
- Lambda functions are secure
- DynamoDB counters are tamper-proof
- Cognito tokens can be validated
- Rate limits protect API costs

### 3.2 Hybrid Solution: Server-Side Enforcement with Client Optimization

#### DynamoDB Schema (Single Table Design)
```javascript
{
  // Partition Key (PK) | Sort Key (SK) pattern

  // User monthly usage
  PK: "USER#user123",
  SK: "USAGE#2024-09",
  interviewCount: 5,
  lastInterviewDate: "2024-09-14",
  quotaLimit: 5,  // From Cognito tier
  resetDate: "2024-10-01"

  // Daily rate limit (prevent abuse)
  PK: "USER#user123",
  SK: "RATELIMIT#2024-09-14",
  requestCount: 3,
  firstRequestTime: "2024-09-14T10:00:00Z",
  blockedUntil: null  // Set if rate limited
}
```

#### Lambda Rate Limiting Logic
```javascript
// generateQuestions Lambda function
exports.handler = async (event) => {
  const userId = event.requestContext.authorizer.claims.sub;
  const userTier = event.requestContext.authorizer.claims['custom:tier'];

  // Check rate limits in DynamoDB
  const usage = await checkUserUsage(userId);

  // Tier-based limits
  const limits = {
    free: { monthly: 5, daily: 3, perHour: 2 },
    premium: { monthly: 999999, daily: 100, perHour: 20 }
  };

  const userLimits = limits[userTier] || limits.free;

  // Enforce limits
  if (usage.monthlyCount >= userLimits.monthly) {
    return {
      statusCode: 429,
      body: JSON.stringify({
        error: 'Monthly quota exceeded',
        limit: userLimits.monthly,
        resetDate: usage.resetDate,
        upgradeUrl: 'https://inkra.app/premium'
      })
    };
  }

  if (usage.dailyCount >= userLimits.daily) {
    return {
      statusCode: 429,
      body: JSON.stringify({
        error: 'Daily limit exceeded',
        retryAfter: 86400 - (Date.now() - usage.firstRequestTime)
      })
    };
  }

  // Process request
  const questions = await generateQuestions(event.body);

  // Update usage counters
  await incrementUsage(userId);

  return {
    statusCode: 200,
    body: JSON.stringify({
      questions,
      usage: {
        used: usage.monthlyCount + 1,
        limit: userLimits.monthly,
        remaining: userLimits.monthly - usage.monthlyCount - 1
      }
    })
  };
};
```

### 3.3 Client-Side Optimization (Not Security)
```swift
// Cache usage locally for better UX (not authoritative)
class UsageTracker {
    @AppStorage("cachedMonthlyUsage") var monthlyUsage = 0
    @AppStorage("cachedUsageLimit") var usageLimit = 5
    @AppStorage("cachedResetDate") var resetDate = Date()

    func canStartInterview() -> Bool {
        // Quick client check (can be bypassed, that's OK)
        return monthlyUsage < usageLimit
    }

    func syncWithServer(_ serverUsage: UsageResponse) {
        // Update cache from authoritative server response
        monthlyUsage = serverUsage.used
        usageLimit = serverUsage.limit
        resetDate = serverUsage.resetDate
    }

    func showUpgradePrompt() {
        // Gracefully handle quota exceeded
        // Server will still enforce if client is hacked
    }
}
```

## 4. AWS COGNITO CONFIGURATION

### 4.1 User Pool Setup
```javascript
{
  "UserPoolName": "inkra-users",
  "Policies": {
    "PasswordPolicy": {
      "MinimumLength": 8,
      "RequireUppercase": true,
      "RequireLowercase": true,
      "RequireNumbers": true
    }
  },
  "Schema": [
    {
      "Name": "email",
      "Required": true,
      "Mutable": false
    },
    {
      "Name": "subscription_tier",
      "AttributeDataType": "String",
      "Mutable": true,
      "DefaultValue": "free"
    },
    {
      "Name": "monthly_quota",
      "AttributeDataType": "Number",
      "Mutable": true,
      "DefaultValue": "5"
    },
    {
      "Name": "stripe_customer_id",
      "AttributeDataType": "String",
      "Mutable": true
    }
  ],
  "AutoVerifiedAttributes": ["email"],
  "MfaConfiguration": "OPTIONAL",
  "UserGroups": [
    {
      "GroupName": "free_tier",
      "Description": "Free users - 5 interviews/month"
    },
    {
      "GroupName": "premium_tier",
      "Description": "Premium users - unlimited"
    }
  ]
}
```

### 4.2 Lambda Authorizer Integration
```javascript
// Custom authorizer to inject user tier into context
exports.authorizer = async (event) => {
  const token = event.authorizationToken;
  const decoded = jwt.verify(token, cognitoPublicKey);

  return {
    principalId: decoded.sub,
    policyDocument: generatePolicy('Allow', event.methodArn),
    context: {
      userId: decoded.sub,
      email: decoded.email,
      tier: decoded['custom:subscription_tier'] || 'free',
      quota: decoded['custom:monthly_quota'] || 5
    }
  };
};
```

## 5. DYNAMODB DESIGN

### 5.1 Single Table Design
**Table Name:** `inkra-usage`

**Primary Key:**
- Partition Key (PK): String
- Sort Key (SK): String

**Global Secondary Indexes:**
- GSI1: For querying by date ranges
  - PK: `DATE#2024-09-14`
  - SK: `USER#user123`

### 5.2 Access Patterns
```
1. Get user's monthly usage
   PK = USER#userId, SK = USAGE#YYYY-MM

2. Get user's daily requests
   PK = USER#userId, SK = RATELIMIT#YYYY-MM-DD

3. Get all users who hit limits today (admin)
   GSI1: PK = DATE#YYYY-MM-DD

4. Increment usage counter
   UpdateItem with ADD operation

5. Reset monthly counters (scheduled Lambda)
   Query SK begins_with USAGE#
```

### 5.3 DynamoDB Operations
```javascript
// Atomic increment with conditional update
const incrementUsage = async (userId) => {
  const date = new Date();
  const monthKey = `USAGE#${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;

  await dynamodb.updateItem({
    TableName: 'inkra-usage',
    Key: {
      PK: `USER#${userId}`,
      SK: monthKey
    },
    UpdateExpression: 'ADD interviewCount :inc SET lastInterviewDate = :date',
    ExpressionAttributeValues: {
      ':inc': 1,
      ':date': date.toISOString()
    },
    ReturnValues: 'ALL_NEW'
  }).promise();
};
```

## 6. LOCAL COREDATA SCHEMA

### 6.1 Simplified Entity Model
```swift
// User Preferences (Singleton)
UserSettings {
    selectedVoiceId: String
    speechRate: Float
    autoSubmitDelay: Float
    defaultInterviewLength: String
    dailyQuestions: [String]  // Transformable
}

// Interview (formerly Project)
Interview {
    id: UUID  // Local only, no server ID
    title: String
    topic: String
    createdDate: Date
    lastModifiedDate: Date
    status: String
    questions: [Question]  // Relationship
    audioSegments: [AudioSegment]  // Relationship
}

// Question
Question {
    id: UUID
    text: String
    order: Int
    isAnswered: Bool
    interview: Interview  // Relationship
    audioSegment: AudioSegment?  // Relationship
}

// AudioSegment
AudioSegment {
    id: UUID
    localFileURL: String  // Path in Documents
    duration: Double
    recordedDate: Date
    transcription: String?
    question: Question  // Relationship
}

// Template Cache (from Lambda)
InterviewTemplate {
    id: String
    title: String
    description: String
    questions: [String]  // Transformable
    lastFetched: Date
}
```

### 6.2 Migration from Current CoreData
```swift
// Current complex structure → Simplified structure
// Remove: Projects, Chapters, Sections (unnecessary nesting)
// Remove: Server IDs (use local UUIDs)
// Remove: Upload tracking (no uploads)
// Remove: Sync timestamps (no sync)
// Add: Direct question-audio relationships
```

## 7. DATA STORAGE LOCATIONS

### 7.1 What Goes Where
```
AWS COGNITO (Managed by AWS):
✓ User credentials (email, password hash)
✓ Subscription tier
✓ Basic profile (name, signup date)
✓ MFA settings

DYNAMODB (Minimal):
✓ Usage counters (monthly, daily)
✓ Rate limit tracking
✓ Last request timestamps
✗ NO user content
✗ NO personal data

COREDATA (On-Device):
✓ All interviews
✓ All questions
✓ All transcriptions
✓ Audio metadata
✓ User preferences
✓ Cached templates

DOCUMENTS DIRECTORY (On-Device):
✓ Audio files (.m4a)
✓ Exported podcasts
✓ Temporary recordings
```

### 7.2 Privacy Benefits
- **Zero knowledge**: Server never sees interview content
- **GDPR compliant**: User can delete everything locally
- **No data breaches**: Nothing sensitive to breach
- **User control**: Export/delete anytime

## 8. IMPLEMENTATION PLAN

### 8.1 Phase 1: AWS Setup (Days 1-2)
```bash
# Cognito User Pool
aws cognito-idp create-user-pool \
  --pool-name inkra-users \
  --schema file://cognito-schema.json

# DynamoDB Table
aws dynamodb create-table \
  --table-name inkra-usage \
  --attribute-definitions \
    AttributeName=PK,AttributeType=S \
    AttributeName=SK,AttributeType=S \
  --key-schema \
    AttributeName=PK,KeyType=HASH \
    AttributeName=SK,KeyType=RANGE \
  --billing-mode PAY_PER_REQUEST
```

### 8.2 Phase 2: Lambda Functions (Days 3-4)
```javascript
// checkUsage.js
exports.handler = async (event) => {
  const userId = event.requestContext.authorizer.claims.sub;

  const usage = await dynamodb.getItem({
    TableName: 'inkra-usage',
    Key: {
      PK: `USER#${userId}`,
      SK: `USAGE#${getCurrentMonth()}`
    }
  }).promise();

  return {
    statusCode: 200,
    body: JSON.stringify({
      used: usage.Item?.interviewCount || 0,
      limit: event.requestContext.authorizer.claims['custom:monthly_quota'],
      resetDate: getNextMonthStart()
    })
  };
};
```

### 8.3 Phase 3: iOS CoreData Migration (Days 5-7)
```swift
// SimplifiedDataManager.swift
class LocalDataManager {
    lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "InkraLocal")

        // Migrate from old model if exists
        let migrationOptions = [
            NSMigratePersistentStoresAutomaticallyOption: true,
            NSInferMappingModelAutomaticallyOption: true
        ]

        container.loadPersistentStores { _, error in
            if let error = error {
                // Handle migration error
                print("Migration failed: \(error)")
            }
        }
        return container
    }()

    func saveInterview(_ topic: String) -> Interview {
        let context = persistentContainer.viewContext
        let interview = Interview(context: context)
        interview.id = UUID()
        interview.title = generateTitle(from: topic)
        interview.topic = topic
        interview.createdDate = Date()

        try? context.save()
        return interview
    }
}
```

### 8.4 Phase 4: Testing & Validation (Days 8-10)
- Test rate limiting with multiple scenarios
- Validate DynamoDB atomic operations
- Test offline functionality
- Security penetration testing

## 9. COST ANALYSIS

### 9.1 Current Costs (PostgreSQL on RDS/Heroku)
```
PostgreSQL instance: $50-100/month
Storage (50GB): $10/month
Backups: $5/month
Read replicas: $50/month (if used)
Total: $115-165/month
```

### 9.2 New Costs (Serverless)
```
AWS Cognito:
- First 50,000 MAU: FREE
- After: $0.0055/MAU
- 10,000 users = $0/month

DynamoDB:
- On-demand pricing
- Writes: $1.25 per million
- Reads: $0.25 per million
- Storage: $0.25/GB/month
- Estimated: $2-5/month

Total: $2-5/month (97% reduction)
```

### 9.3 Free Tier Benefits
```
Cognito: 50,000 MAU free
DynamoDB: 25GB storage, 25 write units, 25 read units free
Lambda: 1M requests, 400,000 GB-seconds free
Total: Likely $0 for first year
```

## 10. SECURITY ANALYSIS

### 10.1 Attack Vectors & Mitigations

#### Client-Side Bypass Attempts
**Attack:** Modify CoreData to show premium tier
**Impact:** UI shows premium, but Lambda still enforces limits
**Mitigation:** Server-side validation on every API call

**Attack:** Replay API requests to bypass rate limits
**Impact:** None, DynamoDB counters are server-side
**Mitigation:** Atomic increments, idempotency keys

**Attack:** Reverse engineer and modify binary
**Impact:** Limited, can't bypass server checks
**Mitigation:** Certificate pinning, obfuscation

#### Server-Side Security
**Attack:** Token forgery
**Mitigation:** Cognito JWT validation with RS256

**Attack:** DDoS on Lambda
**Mitigation:** API Gateway throttling, WAF rules

**Attack:** Data injection
**Mitigation:** Input validation, parameterized queries

### 10.2 Security Best Practices
```swift
// iOS Security
class SecurityManager {
    // Certificate pinning
    func pinCertificate() {
        let pinnedCertificates = [
            "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
        ]
        // Implement pinning
    }

    // Encrypt sensitive local data
    func encryptCoreData() {
        let options = [
            NSPersistentStoreFileProtectionKey: FileProtectionType.complete
        ]
        // Apply encryption
    }

    // Detect jailbreak
    func isJailbroken() -> Bool {
        // Check for common jailbreak indicators
        return false
    }
}
```

## 11. MIGRATION STRATEGY

### 11.1 Data Migration Plan
```
Step 1: Export existing users from PostgreSQL
Step 2: Import users to Cognito (batch job)
Step 3: Initialize DynamoDB usage records
Step 4: Deploy new Lambda functions
Step 5: Update iOS app with feature flag
Step 6: Gradual rollout (1% → 10% → 50% → 100%)
Step 7: Decommission PostgreSQL
```

### 11.2 Rollback Plan
```
- Feature flags for instant rollback
- Dual-write period (both DBs)
- Data export before cutover
- 30-day PostgreSQL retention
```

## 12. MONITORING & OBSERVABILITY

### 12.1 CloudWatch Metrics
```javascript
// Custom metrics to track
const metrics = {
  'RateLimitHits': count of 429 responses,
  'UsageQuotaExceeded': monthly limit hits,
  'DynamoDBThrottles': capacity exceptions,
  'CognitoAuthFailures': login failures
};

// Alarms
const alarms = {
  'HighRateLimitHits': threshold > 100/hour,
  'DynamoDBErrors': any errors,
  'LambdaColdStarts': p99 > 1 second
};
```

### 12.2 User Analytics (Privacy-Preserving)
```swift
// Only track aggregated, anonymous metrics
struct AnonymousMetrics {
    let interviewsPerWeek: Int  // Averaged, not per-user
    let averageDuration: TimeInterval
    let featureAdoption: [String: Float]  // Percentages only
    // NO user IDs, NO content, NO personal data
}
```

## 13. ADVANTAGES OF THIS ARCHITECTURE

### 13.1 For Users
✅ **Complete privacy**: Data never leaves device
✅ **Instant access**: No network latency for content
✅ **Offline capable**: Works without internet
✅ **No data breaches**: Nothing to breach
✅ **User control**: Delete everything instantly

### 13.2 For Business
✅ **97% cost reduction**: $165/mo → $5/mo
✅ **Zero maintenance**: Managed services
✅ **Infinite scale**: Serverless auto-scaling
✅ **GDPR compliant**: No data processing
✅ **Competitive advantage**: Privacy as feature

### 13.3 Technical Benefits
✅ **No migrations**: Schema changes are local
✅ **No backups needed**: Users own their data
✅ **No replication**: Single source of truth
✅ **No consistency issues**: No distributed state
✅ **Simple architecture**: Fewer moving parts

## 14. POTENTIAL CHALLENGES & SOLUTIONS

### Challenge 1: User Expects Cloud Sync
**Solution:** Position as privacy feature, not limitation
```swift
// Messaging in app
"Your interviews are private and secure, stored only on your device.
Export to iCloud Drive anytime for backup."
```

### Challenge 2: Device Storage Limits
**Solution:** Smart cleanup + compression
```swift
class StorageManager {
    func compressOldAudio() {
        // Convert old interviews to lower bitrate
    }

    func suggestCleanup() {
        // Prompt user to export & delete old content
    }
}
```

### Challenge 3: Lost Device = Lost Data
**Solution:** Optional encrypted iCloud backup
```swift
// User-controlled backup
class BackupManager {
    func backupToiCloud() {
        // Encrypt and upload to user's iCloud
        // User owns the encryption key
    }
}
```

## 15. IMPLEMENTATION CHECKLIST

### AWS Setup
- [ ] Create Cognito User Pool
- [ ] Configure user attributes
- [ ] Set up user groups (free/premium)
- [ ] Create DynamoDB table
- [ ] Configure GSI for date queries
- [ ] Deploy Lambda functions
- [ ] Set up API Gateway
- [ ] Configure CloudWatch alarms

### iOS Changes
- [ ] Simplify CoreData model
- [ ] Remove sync logic
- [ ] Implement Cognito auth
- [ ] Add DynamoDB client
- [ ] Update rate limiting UI
- [ ] Add usage tracking display
- [ ] Implement offline mode
- [ ] Add data export feature

### Migration
- [ ] Export PostgreSQL data
- [ ] Script user migration
- [ ] Test with subset
- [ ] Plan rollout schedule
- [ ] Prepare rollback procedure
- [ ] Document runbooks

## CONCLUSION

This database architecture achieves the perfect balance:

1. **Server-side rate limiting** (secure, trustworthy)
2. **Client-side content storage** (private, fast)
3. **Minimal cloud footprint** (cheap, simple)

By leveraging AWS managed services (Cognito + DynamoDB) for only what's absolutely necessary (auth + rate limiting), and keeping all user content on-device, we achieve:

- **97% cost reduction** ($165 → $5/month)
- **100% privacy** (no content leaves device)
- **Instant performance** (no network for content)
- **Simple maintenance** (managed services)
- **Secure rate limiting** (can't be bypassed)

The key insight: **You don't need a database for single-user mobile apps**. The device IS the database. The cloud is just for auth and abuse prevention.